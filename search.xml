<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Talking about C++ Memory Management</title>
      <link href="2021/05/05/talking-about-c-memory-management/"/>
      <url>2021/05/05/talking-about-c-memory-management/</url>
      
        <content type="html"><![CDATA[<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="对齐设置"><a href="#对齐设置" class="headerlink" title="对齐设置"></a>对齐设置</h2><p>每个平台的编译器都有自己默认的对齐系数。gcc中默认#pregma pack(4)，也可以通过与编译命令自己修改<br><strong>有效对齐值</strong>：定值 <strong>#pragma pack(n)</strong> 和 <strong>结构体中最长数据类型</strong> 长度中较小的那个。有效对齐值也叫对齐单位</p><h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><p>1、变量的起始位置可以被其对齐值整除。<br>2、结构体里面的成员相对与起始位置的偏移量，可以被该成员大小与有效对齐值中较小那个整除。如果不行，就在前面一个成员的后面补充字节。<br>3、结构体总大小可以被有效对齐值整除。如果不行，则在后面补充字节。</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>1、减少使用的内存<br>2、提升数据读取的效率</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Test{char a;int b;short c;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>char的对齐值是1，int 的对齐值是4， short的对齐值是2，整个结构体的对齐值是4。对齐值可以用alignof获取得到。<br>假设结构体变量的起始地址已经对齐，第一个成员后面需要补充3个字节后第二成员才可以对齐。第三个成员后面需要补充2两个字节后才能满足原则三。所以这个结构体的总大小为12字节。<br>当我们改变结构体成员的顺序后</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">struct Test{int b;short c;char a;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时结构体的总大小为8。由此可以看出，适当安排成员的顺序可以减少内存的使用。</p><h1 id="操作系统和内存管理机制"><a href="#操作系统和内存管理机制" class="headerlink" title="操作系统和内存管理机制"></a>操作系统和内存管理机制</h1><h2 id="windows内存管理机制"><a href="#windows内存管理机制" class="headerlink" title="windows内存管理机制"></a>windows内存管理机制</h2><p>操作系统将Physical Memory映射为连续的Virtual Memory，并提供相关api来对vm进行管理，在virtual Memory api 之上又构建了Heap Memory API。<strong>C的内存管理机制就是构建在Heap Memory api之上的。</strong><br>使用Virtual Alloc分配内存时，每次只能分配页面大小(默认4KB)整数倍的连续虚拟内存(但是两次连续调用所分配的内存并不一定连续)。</p><h2 id="linux内存管理机制"><a href="#linux内存管理机制" class="headerlink" title="linux内存管理机制"></a>linux内存管理机制</h2><p>linux中可以使用brk或者mmap函数从用户空间中申请连续内存<br>通过调用brk(0)可以获取指向用户空间某一地址的指针，随后调用brk(len)可以在原指针地址的基础上移动该指针以达到申请或释放内存的目的。而mmap则是直接在用户空间中申请一块连续的空闲内存。</p><h2 id="C内存管理机制"><a href="#C内存管理机制" class="headerlink" title="C内存管理机制"></a>C内存管理机制</h2><p><a href="https://imgtu.com/i/gKZtzV"><img src="https://z3.ax1x.com/2021/05/05/gKZtzV.png" alt="c内存布局"></a></p>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++,IT,Skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let&#39;s Learn Git Now!</title>
      <link href="2021/05/05/let-s-learn-git-now/"/>
      <url>2021/05/05/let-s-learn-git-now/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础知识"><a href="#Git基础知识" class="headerlink" title="Git基础知识"></a>Git基础知识</h1><h2 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h2><p>本地项目目录通过 <strong>git add file</strong> 将项目提交到 <strong>暂存区</strong>，暂存区通过 <strong>git commit</strong> 将项目提交到 <strong>本地仓库</strong>，本地仓库通过 <strong>git push</strong> 将项目提交到远程仓库。<br>通过 <strong>git pull</strong> 将项目仓远程仓库拉取到 <strong>本地仓库</strong> ， 通过 <strong>git reset</strong> 将代码从本地仓库回滚到<strong>暂存区</strong> ，通过 <strong>git checkout</strong> 将代码从暂存区回退到 <strong>工作目录</strong><br><a href="https://imgtu.com/i/gKSXlj"><img src="https://z3.ax1x.com/2021/05/05/gKSXlj.png" alt="工作区域示意图"></a></p><h2 id="忽略提交"><a href="#忽略提交" class="headerlink" title="忽略提交"></a>忽略提交</h2><p>在根目录下建立 <strong>.gitignore</strong> 文件</p><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#为注释</span>*.txt<span class="token comment">#忽略所有以 .txt 结尾的文件</span><span class="token operator">!</span>lib.txt<span class="token comment">#但是lib.txt除外</span>/temp<span class="token comment">#仅仅忽略根目录下的temp，子目录不忽略</span>build/<span class="token comment">#忽略build/目录下的所有文件，包括子目录</span>doc/*.txt<span class="token comment">#忽略当前目录下的 .txt结尾的文件，但是子目录里面的不包括</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>1、该配置文件的空行和井号都会被忽略<br>2、可以使用通配符如：* 表示多个字符 ，？表示一个字符， 方括号表示字符可选范围， 大括号表示可选字符串<br>3、如果名称的前面是一个感叹号，说明除此之外<br>4、如果名称的最前面是一个分隔符，表示要忽略的文件在次目录下，不过子目录不包括<br>5、名称的后面有一个分隔符，表示忽略此目录下该名称的子目录</p>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git,IT,Skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let&#39;s Learn GoLang Now!</title>
      <link href="2021/02/28/let-s-learn-golang-now/"/>
      <url>2021/02/28/let-s-learn-golang-now/</url>
      
        <content type="html"><![CDATA[<h1 id="Go语言开发环境搭建"><a href="#Go语言开发环境搭建" class="headerlink" title="Go语言开发环境搭建"></a>Go语言开发环境搭建</h1><h2 id="Go安装"><a href="#Go安装" class="headerlink" title="Go安装"></a>Go安装</h2><h3 id="下载Go安装包"><a href="#下载Go安装包" class="headerlink" title="下载Go安装包"></a>下载Go安装包</h3><p>Go的官方镜像下载地址： <a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a><br><a href="https://imgtu.com/i/6CWGdS"><img src="https://s3.ax1x.com/2021/02/28/6CWGdS.png" alt="Go下载按钮"></a><br>下载之后一路点击下一步就行，安装位置选择方便好记的地方就行了</p><h3 id="检查安装是否成功"><a href="#检查安装是否成功" class="headerlink" title="检查安装是否成功"></a>检查安装是否成功</h3><p><a href="https://imgtu.com/i/6Cf51s"><img src="https://s3.ax1x.com/2021/02/28/6Cf51s.png" alt="打开命令控制行"></a><br>打开命令控制行<br>输入命令 <strong>go version</strong> ，出现如图所示的版本号即代表安装成功<br><a href="https://imgtu.com/i/6ChPHK"><img src="https://s3.ax1x.com/2021/02/28/6ChPHK.png" alt="检查版本号"></a></p><h2 id="配置Go目录"><a href="#配置Go目录" class="headerlink" title="配置Go目录"></a>配置Go目录</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>这一步的目的是用于指示Go我们的项目文件都放在哪里。首先新建一个文件夹，这个文件夹就是我们以后放项目文件的目录。然后将这个路径添加到系统环境变量GOPATH中去。<br><a href="https://imgtu.com/i/6C4hyn"><img src="https://s3.ax1x.com/2021/02/28/6C4hyn.png" alt="添加环境变量操作示例"></a><br>系统有一个默认的GOPATH，删掉即可<br><a href="https://imgtu.com/i/6CIRrn"><img src="https://s3.ax1x.com/2021/02/28/6CIRrn.png" alt="删除示例"></a></p><h3 id="配置GOPATH目录"><a href="#配置GOPATH目录" class="headerlink" title="配置GOPATH目录"></a>配置GOPATH目录</h3><p><a href="https://imgtu.com/i/6CI9un"><img src="https://s3.ax1x.com/2021/02/28/6CI9un.png" alt="新建目录示例"></a><br>在GOPATH目录下新建三个文件夹，并将<strong>bin的路径添加到系统环境变量Path</strong>中去</p><h3 id="基本目录结构"><a href="#基本目录结构" class="headerlink" title="基本目录结构"></a>基本目录结构</h3><p><strong>个人项目的基本目录结构</strong>如图所示，网站域名一般是自己个人github的域名，以自己床衰败的用户名来区分包<br><a href="https://imgtu.com/i/6CokqI"><img src="https://s3.ax1x.com/2021/02/28/6CokqI.png" alt="个人人项目的基本目录结构"></a><br><strong>企业项目的基本目录结构</strong>如图所示<br><a href="https://imgtu.com/i/6CoUWF"><img src="https://s3.ax1x.com/2021/02/28/6CoUWF.png" alt="企业项目的基本目录"></a><br>目录结构示例<br><a href="https://imgtu.com/i/6CoWSe"><img src="https://s3.ax1x.com/2021/02/28/6CoWSe.png" alt="文件示例"></a></p><h2 id="VsCode部分"><a href="#VsCode部分" class="headerlink" title="VsCode部分"></a>VsCode部分</h2><h3 id="VsCode下载安装"><a href="#VsCode下载安装" class="headerlink" title="VsCode下载安装"></a>VsCode下载安装</h3><p>这一部分就比较简单了，一般大家都会吧。<br>安装中文插件<br><a href="https://imgtu.com/i/6C7SjH"><img src="https://s3.ax1x.com/2021/02/28/6C7SjH.png" alt="安装中文插件"></a><br>安装Go插件<br><a href="https://imgtu.com/i/6C7kUP"><img src="https://s3.ax1x.com/2021/02/28/6C7kUP.png" alt="安装Go插件"></a> </p><h3 id="Go的配置代理"><a href="#Go的配置代理" class="headerlink" title="Go的配置代理"></a>Go的配置代理</h3><p>vscode会提示你安装go的相关依赖，相信我，点击install all 也安装不成功的。国内的环境你懂的。<br>所以打开命令行，输入<code>go env -w GOPROXY=https://goproxy.cn,direct</code>配置Go的代理<br>之后就可以正常安装啦<br><a href="https://imgtu.com/i/6CbQhV"><img src="https://s3.ax1x.com/2021/02/28/6CbQhV.png" alt="代理后安装依赖的过程"></a></p><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p><a href="https://imgtu.com/i/6C7KDs"><img src="https://s3.ax1x.com/2021/02/28/6C7KDs.png" alt="新建第一个文件"></a><br><a href="https://imgtu.com/i/6CqKDH"><img src="https://s3.ax1x.com/2021/02/28/6CqKDH.png" alt="代码示例"></a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="基本编译方法"><a href="#基本编译方法" class="headerlink" title="基本编译方法"></a>基本编译方法</h2><p>在项目所在目录打开命令行，输入<code>go build</code>或者 <code>go build -o 重新命的名.exe</code><br>在其他任何目录，输入<code>go build xx/xx/xx/项目目录（从GOATH/src/之后开始写起）</code><br>使用<code>go install</code>，不仅编译，而且会将编译好的文件放到<strong>GOPATH/bin</strong>目录下<br><a href="https://imgtu.com/i/6CLSit"><img src="https://s3.ax1x.com/2021/02/28/6CLSit.png" alt="执行go install"></a></p><h2 id="跨平台编译"><a href="#跨平台编译" class="headerlink" title="跨平台编译"></a>跨平台编译</h2><p>假如我需要在windows上编译一个在Linux上运行的项目。编译前设置相关的环境变量<br><a href="https://imgtu.com/i/6CLNJx"><img src="https://s3.ax1x.com/2021/02/28/6CLNJx.png" alt="跨平台编译环境变量设置"></a><br>执行编译后得到了在linux下运行的可执行文件<br><a href="https://imgtu.com/i/6CLdSK"><img src="https://s3.ax1x.com/2021/02/28/6CLdSK.png" alt="编译"></a></p><h1 id="Gorilla"><a href="#Gorilla" class="headerlink" title="Gorilla"></a>Gorilla</h1><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><p>非用户主动请求而获取到的数据</p><h2 id="通道与协程"><a href="#通道与协程" class="headerlink" title="通道与协程"></a>通道与协程</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//fmt.Printf("hello world")</span>chA <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>chB <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">{</span><span class="token keyword">select</span> <span class="token punctuation">{</span><span class="token keyword">case</span> va <span class="token operator">:=</span> <span class="token operator">&lt;-</span>chA<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"channel A"</span><span class="token punctuation">,</span> va<span class="token punctuation">)</span><span class="token keyword">case</span> vb <span class="token operator">:=</span> <span class="token operator">&lt;-</span>chB<span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"channel B"</span><span class="token punctuation">,</span> vb<span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"nothing happened"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>chA <span class="token operator">&lt;-</span> <span class="token number">1</span>chA <span class="token operator">&lt;-</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>chB <span class="token operator">&lt;-</span> <span class="token number">1</span>chB <span class="token operator">&lt;-</span> <span class="token number">2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgtu.com/i/6EsmE8"><img src="https://s3.ax1x.com/2021/03/03/6EsmE8.png" alt="代码运行截图1"></a></p>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GoLang,IT,Skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let&#39;s Learn Multithreading Now</title>
      <link href="2021/02/13/let-s-learn-multithreading-now/"/>
      <url>2021/02/13/let-s-learn-multithreading-now/</url>
      
        <content type="html"><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><p>并行：在同一时间点发生。<br>并发：在某个时间段内同时发生。</p><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程：<strong>运行起来了</strong>的可执行文件。<br>线程：代码的一条执行通路，可以通过自己写代码来创建其他线程。<br>主线程：进程执行起来了之后，就会有一个唯一的主线程默默启动，寿命和进程同步。<br>多线程：一个进程里，多个线程并发进行。<strong>但是如果多个线程同时去访问一个资源的话，很容易出问题。</strong></p><h2 id="并发的实现方法"><a href="#并发的实现方法" class="headerlink" title="并发的实现方法"></a>并发的实现方法</h2><p>1、创建多个进程（进程之间的通信：管道文件，信息队列，共享内存，socket通信）<br>2、单独一个进程创建多个线程（每个线程有自己独立的运行路径，所有线程共享进程内存。<strong>需要考虑到数据的一致性</strong>）<br>所以优先考虑多线程的并发技术使用。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>C++11的新标准线程库，增加了对多线程的支持，可以执行大大提高。（以往：windows：createthread()使用创建线，linux:pthread_create，以往的基本不能跨平台）</p><h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><h2 id="thread-，join-，detach-，joinable"><a href="#thread-，join-，detach-，joinable" class="headerlink" title="thread()，join()，detach()，joinable()"></a>thread()，join()，detach()，joinable()</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">myprint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我自己创造的线程1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程1结束"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">TA</span> <span class="token punctuation">{</span><span class="token keyword">int</span> <span class="token operator">&amp;</span>m_i<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">TA</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token function">m_i</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//重载括号，线程入口</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"m_i 的值为"</span> <span class="token operator">&lt;&lt;</span>m_i<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程2结束"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//自己创建一个线程，也要从一个函数开始。主线程结束了，如子线程没有执行完毕，可能会被强行终结。</span><span class="token comment">//现在就是有两条线路在跑。即使一条路堵住了，不耽误另一条执行</span><span class="token comment">//thread是一个类，括号里的参数myprint是可调用对象</span>thread <span class="token function">myobj</span><span class="token punctuation">(</span>myprint<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建了线程，入口是myprint函数</span><span class="token keyword">if</span> <span class="token punctuation">(</span>myobj<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"joinable == true"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"joinable==false"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>myobj<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//阻塞主线程，希望主线程等待子线程，等我子线程执行完再放行。不添加join，可能子线程还没执行完，你就结束了。</span><span class="token comment">//myobj.detach();//使用了之后，就不能改join了</span><span class="token keyword">int</span> myi <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>TA <span class="token function">ta</span><span class="token punctuation">(</span>myi<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用了构造函数。参数引用进去的，有隐患。在主线程里，如果主线程结束了，就不能打印它的值了</span>thread <span class="token function">myobj2</span><span class="token punctuation">(</span>ta<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用类对象来创建子线程。这里调用了拷贝构造函数</span>myobj2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Q：一旦调用了detach，主线程没了，我还能使用这个类吗，还能使用他的成员函数吗？</span><span class="token comment">//A：可以。ta对象已经被复制到子线程中了，生成了一个新的类对象。二者没有关系了</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i love china1"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//主线程,从main函数开始执行</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i love china2"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h2><p>建议值传递，尽量不要使用引用和传指针。不要使用隐式类型转换，在创建线程的时候就把类型转换好。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//void myprint(const int&amp; i, char* mprint) {</span><span class="token keyword">void</span> <span class="token function">myprint</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> i<span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span>mprint<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//正确写法，用引用来接参数</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> mprint <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">myprint2</span><span class="token punctuation">(</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> up<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//正确写法，用引用来接参数</span><span class="token comment">//cout &lt;&lt; i &lt;&lt; endl;</span><span class="token comment">//cout &lt;&lt; mprint &lt;&lt; endl;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> m_a<span class="token punctuation">;</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">m_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ok"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">thread_work</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"任意成员函数thread_work启动"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">myprint3</span><span class="token punctuation">(</span>A a<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">.</span>m_a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//cout &lt;&lt; mprint &lt;&lt; endl;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span><span class="token operator">&amp;</span> myarray <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"this is a test"</span><span class="token punctuation">;</span><span class="token comment">//thread myobj(myprint, myarray, buf);//函数名，函数的各参数。不要使用引用和传指针。有隐患</span>thread <span class="token function">myobj</span><span class="token punctuation">(</span>myprint<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//正确写法,在创建线程的时候就把类型转换好，用临时的对象做参数来赋值，它一定会在进程结束前被构造出来。不论join还是detach</span>myobj<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">myobj2</span><span class="token punctuation">(</span>myprint3<span class="token punctuation">,</span>std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a在线程里会被修改</span><span class="token comment">//往线程里传递类对象的参数，不论你是不是引用，系统会默认使用拷贝，原来的主线程里的不会被改变。如果我想要要改，不希望被拷贝，则使用std::ref</span>myobj2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//传递智能指针.需要使用move函数，才能正确</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">myp</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">myobj3</span><span class="token punctuation">(</span>myprint2<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>myp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myobj3<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用任意的成员函数来作为线程的入口</span>A <span class="token function">a2</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">myobj4</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>thread_work<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//入口：类函数，告诉你是具体哪个对象的函数，函数的参数……。也可把std::ref(a2)改成&amp;a2</span>myobj4<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="容器管理线程"><a href="#容器管理线程" class="headerlink" title="容器管理线程"></a>容器管理线程</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">myprint</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"myprint线程开始了，编号："</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"myprint线程结束了，编号："</span> <span class="token operator">&lt;&lt;</span> num <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//创建和等待多个线程</span>vector<span class="token operator">&lt;</span>thread<span class="token operator">&gt;</span> mythreads<span class="token punctuation">;</span><span class="token comment">//使用容器管理各个线程</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>mythreads<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">thread</span><span class="token punctuation">(</span>myprint<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建了十个线程.执行顺序是乱的，很复杂，很随机</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> mythreads<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> mythreads<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>iter<span class="token operator">-&gt;</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//等待十个线程</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i love china"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="互斥量和锁"><a href="#互斥量和锁" class="headerlink" title="互斥量和锁"></a>互斥量和锁</h1><h2 id="mutex，lock-，unlock-，lock-guard"><a href="#mutex，lock-，unlock-，lock-guard" class="headerlink" title="mutex，lock()，unlock()，lock_guard"></a>mutex，lock()，unlock()，lock_guard</h2><p>对于只读数据，不怎么需要特别注意的地方.对于有读有写的数据，比如2个写，八个来读，如果没有特别处理，会出问题。所以读的时候不能写，写的时候不能读，写的时候其他线程不能读写.<br>引入互斥量mutex的概念，使用lock（）加锁，只有一个线程能够锁定成功，成功的标志是返回了。没成功就是一直会等待锁成功。<br>lock()和unlock()成对使用（**这里的成对是指每个分支要成对，不是数量上的成对，比如if有两个出口，两个出口都要写unlock()**），在需要保护共享数据的地方加。<br>怕你忘记。所以有一个东西叫lockguard的类模板，帮你自动lock()，unlock()。用了lockguard另外两个就不许用了。原理，lockguard构造即执行了lock()，它析构的时候会执行unlock()。可以使用{}指定lockguard的作用范围。</p><p>死锁问题，必须有两个互斥量以上才有可能发生。比如：线程A：正在锁金锁，锁完之后，它准备去锁银锁……被切换了。线程B：正在锁银锁，银锁锁完了，它准备去锁金锁……<br>解决办法：保证上锁的顺序一致即可。大家都先锁金锁再上银锁。<br>std::lock(互斥锁1，互斥锁2，……)函数使用。在分别上锁的时候，如果遇到不能上锁的情况下，它会先释放自己已经锁了的，过一会再来尝试</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> shared_v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//共享数据</span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">inMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//线程1，插入命令到消息队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"插入命令："</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span><span class="token function">lock</span><span class="token punctuation">(</span>my_mutex1<span class="token punctuation">,</span> my_mutex2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于每一个互斥量执行lock操作，</span>std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbgurad1</span><span class="token punctuation">(</span>my_mutex1<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//智能lock,构造时会自动执行lock函数。但是前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题</span>std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbgurad2</span><span class="token punctuation">(</span>my_mutex2<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//智能lock,构造时会自动执行lock函数。但是前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">outMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//线程2，读取命令到消息队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>my_mutex1<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上锁</span>my_mutex2<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上锁</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//消息不为空</span><span class="token keyword">int</span> command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理数据</span>my_mutex1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my_mutex2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//消息为空</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"读取命令，但是消息队列是空的"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>my_mutex1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//因为有两个出口，所以每个出口都要写上unlock</span>my_mutex2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> msgRecvQueue<span class="token punctuation">;</span><span class="token comment">//玩家命令</span>std<span class="token operator">::</span>mutex my_mutex1<span class="token punctuation">;</span><span class="token comment">//创建一个互斥量</span>std<span class="token operator">::</span>mutex my_mutex2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">myprint</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"id:"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"线程打印shared_v数据"</span> <span class="token operator">&lt;&lt;</span> shared_v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> shared_v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> shared_v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>A myobj<span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>outMsgRecvQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myobj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二个参数是引用，这样才能保证操作的是同一个对象</span>std<span class="token operator">::</span>thread <span class="token function">mythread2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>inMsgRecvQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myobj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二个参数是引用，这样才能保证操作的是同一个对象</span>mythread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mythread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h1><h2 id="try-lock-，release"><a href="#try-lock-，release" class="headerlink" title="try_lock()，release()"></a>try_lock()，release()</h2><p>uniquelock里面的成员函数：内置unlock（）的作用：就是假设你有时候相处离别的非共享代码的时候想解锁了，可以手动设置成unlock。弄完了再回来加锁。 try_lock（），尝试加锁，成功返回true，失败返回false。<br>release（）释放对于mutex的管理权，sbguard和mutex取消关系，返回的是互斥量的指针。<br>则需要你自己手动unlock。std::mutex * ptx = sbgurad2.release();  ptx-&gt;unlock();<br>锁住的代码少，粒度小，执行效率高。锁住的代码多，粒度大，效率低。<br>uniquelock的所有权的传递，一个uniquelock和一个mutex配对，所有权可以转移。使用std::unique_lock<a href="std::mutex">std::mutex</a> sbgurad2(std::move(sbgurad1));实现转移。也可以通过函数，构造临时对象，获得所有权，然后return给调用函数的对象。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">inMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//线程1，插入命令到消息队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"插入命令："</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>my_mutex1<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于每一个互斥量执行lock操作，</span>std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbgurad1</span><span class="token punctuation">(</span>my_mutex1<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//智能lock,构造时会自动执行lock函数。前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题</span>std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbgurad2</span><span class="token punctuation">(</span>my_mutex2<span class="token punctuation">,</span> std<span class="token operator">::</span>try_to_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//unique_lock比lockguard好用，但是效率低，占用多,try_to_lock（不能先lock）不会卡住，拿不到锁就马上返回走人</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sbgurad2<span class="token punctuation">.</span><span class="token function">owns_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//检查是否拿到了锁，和try_lock使用场景类似</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"没拿到锁，只能干点别的事"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">outMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//线程2，读取命令到消息队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbguarde1</span><span class="token punctuation">(</span>my_mutex1<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbguarde2</span><span class="token punctuation">(</span>my_mutex2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//std::chrono::milliseconds dura(20000);//休息20000毫秒</span><span class="token comment">//std::this_thread::sleep_for(dura);</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//消息不为空</span><span class="token keyword">int</span> command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理数据</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//消息为空</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"读取命令，但是消息队列是空的"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> msgRecvQueue<span class="token punctuation">;</span><span class="token comment">//玩家命令</span>std<span class="token operator">::</span>mutex my_mutex1<span class="token punctuation">;</span><span class="token comment">//创建一个互斥量</span>std<span class="token operator">::</span>mutex my_mutex2<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>call_once(),该函数的第二个参数，是一个函数名，能够保证这个函数只被调用一次。具备互斥量的能力。配合使用once_flag，标记该函数是否已经被调用了。如果已经被调用了，就不会再被调用了</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>mutex mymutex1<span class="token punctuation">;</span>std<span class="token operator">::</span>once_flag g_flag<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">myCAS</span> <span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//我们需要的只被调用一次的函数</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">20000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"createInstance()被执行了"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>m_instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">myCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> laJiHuiShou cl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token function">myCAS</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment">//把构造函数私有化了，不能轻易构造对象了</span><span class="token keyword">static</span> myCAS<span class="token operator">*</span> m_instance<span class="token punctuation">;</span><span class="token comment">//静态成员</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">static</span> myCAS <span class="token operator">*</span> <span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//只给第一次出现的，进行new对象操作</span><span class="token comment">//if (m_instance == NULL) {//双重认定</span><span class="token comment">//if (m_instance == NULL) {</span><span class="token comment">//std::unique_lock&lt;std::mutex&gt; sbguard(mymutex1);//如果是子线程来生成单例模式下的对象，需要进行加锁，防止</span><span class="token comment">//m_instance = new myCAS();</span><span class="token comment">//static laJiHuiShou cl;</span><span class="token comment">//}</span><span class="token comment">//}</span><span class="token comment">//上方代码更高效</span>std<span class="token operator">::</span><span class="token function">call_once</span><span class="token punctuation">(</span>g_flag<span class="token punctuation">,</span> createInstance<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//两个线程执行到这里，只有一个会被成功执行</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call_once()被执行完毕"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> m_instance<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">laJiHuiShou</span> <span class="token punctuation">{</span><span class="token comment">//为了完美，垃圾主动回收一下</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token operator">~</span><span class="token function">laJiHuiShou</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>myCAS<span class="token operator">::</span>m_instance<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">delete</span> myCAS<span class="token operator">::</span>m_instance<span class="token punctuation">;</span>myCAS<span class="token operator">::</span>m_instance <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//类静态变量初始化</span>myCAS <span class="token operator">*</span>myCAS<span class="token operator">::</span>m_instance <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">//设计模式</span><span class="token comment">//单例设计模式：由某个或者某些特殊的类，属于这个类的对象，只能创建一个 。我就只对这一个对象进行操作</span>myCAS<span class="token operator">*</span> p_a <span class="token operator">=</span> myCAS<span class="token operator">::</span><span class="token function">GetInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//建议在主线程中生成对象之后，把所有的数据加载完之后，改成只读模式。后面对其进行独操作就不用特地上锁了</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="条件变量condition-variable"><a href="#条件变量condition-variable" class="headerlink" title="条件变量condition_variable"></a>条件变量condition_variable</h1><h2 id="wait-，notify-one"><a href="#wait-，notify-one" class="headerlink" title="wait()，notify_one()"></a>wait()，notify_one()</h2><p>wait()：等一个东西。如果第二个参数的表达式返回的是false，解锁互斥量，开始阻塞。阻塞至其他线程调用notify_one()函数为止.唤醒之后，就会不断获取锁。获取到之后，上锁。如果wait()没有第二个参数，则默认返回false<br>notify_one()：唤醒一个在wait()的线程.假如没有线程在wait()，这个唤醒就没意义</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">void</span> <span class="token function">inMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//线程1，插入命令到消息队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"inMsgRecvQueue执行，插入一个元素"</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbguard1</span><span class="token punctuation">(</span>my_mutex1<span class="token punctuation">)</span><span class="token punctuation">;</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>my_conditionV<span class="token punctuation">.</span><span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//唤醒一个在wait的线程.假如没有线程在wait，这个唤醒就没意义</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">outMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//线程2，读取命令到消息队列</span><span class="token keyword">int</span> command <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token operator">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbguard1</span><span class="token punctuation">(</span>my_mutex1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上锁互斥量</span>my_conditionV<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>sbguard1<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token comment">//wait（）,等一个东西。如果第二个参数的表达式返回的是false，解锁互斥量，开始阻塞。</span> <span class="token comment">//阻塞至其他线程调用notify_one（）函数为止.唤醒之后，就会不断获取锁。获取到之后，上锁</span><span class="token comment">//如果wait（）没有第二个参数，则默认返回false</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//这里不一定立马竞争锁成功了，可能等取命令竞争完了，插入了很多条数据了</span>command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"outMsgRecvQueue执行，取出一个元素"</span> <span class="token operator">&lt;&lt;</span> command <span class="token operator">&lt;&lt;</span> <span class="token string">",threadID"</span><span class="token operator">&lt;&lt;</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>sbguard1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//因为我已经取完了，就先解锁，让写操作继续进行。线程还不够完美：我们应该把里面的命令全部取出</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> msgRecvQueue<span class="token punctuation">;</span><span class="token comment">//玩家命令</span>std<span class="token operator">::</span>mutex my_mutex1<span class="token punctuation">;</span><span class="token comment">//创建一个互斥量</span>std<span class="token operator">::</span>condition_variable my_conditionV<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//条件变量condition_variable，wait（），notify_one（）：唤醒一个。notify_all()：唤醒全部在wait的线程</span>A myobja<span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">myOutMsg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>outMsgRecvQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myobja<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//myobja是引用，因为要和inMsgRecvQueue操作共用</span>std<span class="token operator">::</span>thread <span class="token function">myInMsg</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>inMsgRecvQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myobja<span class="token punctuation">)</span><span class="token punctuation">;</span>myInMsg<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myOutMsg<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="async函数模板"><a href="#async函数模板" class="headerlink" title="async函数模板"></a>async函数模板</h1><h2 id="std-future-std-launch"><a href="#std-future-std-launch" class="headerlink" title="std::future,std::launch"></a>std::future,std::launch</h2><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token keyword">int</span> mypra<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程开始执行啦，threadid为"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> mypra <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程执行结束啦，threadid为"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//std::async,std::future,std::launch(线程会延迟到)</span><span class="token comment">//希望线程返回结果</span><span class="token comment">//async是一个函数模板，启动一个异步任务：自动创建一个线程，并开始执行对应线程的入口函数</span>A a<span class="token punctuation">;</span><span class="token keyword">int</span> tmppra <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main启动，threadid="</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span>get_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>mythread<span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span>tmppra<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建了一个线程，入口函数为mythread（这个函数必须要返回一个值，不然后面有问题）。rusult还没这么快得到值，将来会拿到。先不管了，程序往下运行</span><span class="token comment">//std::future&lt;int&gt; result = std::async(std::launch::deferred,&amp;A::mythread,&amp;a,tmppra);//deferred延迟调用，遇到get和wait使用之后再会开始调用</span><span class="token comment">//std::future&lt;int&gt; result = std::async(std::launch::async, &amp;A::mythread, &amp;a, tmppra);//立即开始执行，不会特地等get和wait的使用</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"continue……！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">int</span> def <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment">//会一直卡在这里，直到result拿到了值，才会继续进行。get（）只能调用一次</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i love china!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//补充</span><span class="token comment">//std::async:创建异步任务</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span>get_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//参数deferred【延迟调用,不创建新线程，只在当前线程下进行任务】，async【强制创建任务】，std::async和std::thread的区别</span>   <span class="token comment">//可能有时async不会创建新的线程。且返回值方便传递出去</span>   <span class="token comment">//使用“或”符号，说明就是两个启动方式都有可能发生，随机二选一</span>   <span class="token comment">//不使用参数，就两个启动方式都有可能发生，随机二选一</span>   <span class="token comment">//如果有时资源紧张，thread操作可能会报异常</span><span class="token comment">//系统如何决定是async还是deferred</span>std<span class="token operator">::</span>future_status status <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//系统停在这里等待一秒钟.status保存result的状态：timeout，ready,deferred</span> <span class="token comment">//也可以写成std::future_status status = result.wait_for(0s);</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果asnyc的第一个参数被设置为std::launch::deferred，本条件成立</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程延迟执行！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//执行完了</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程执行完了！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//超时</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"超时了，线程还没有执行完！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h1><p>packaged_task的使用：把函数包装起来,实现更多接口。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span> std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> myTask<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token keyword">int</span> mypra<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程开始执行啦，threadid为"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> mypra <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程执行结束啦，threadid为"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//packaged_task的使用：把函数包装起来,实现更多接口</span><span class="token comment">//写法1</span><span class="token comment">//std::pakage_task</span><span class="token comment">//cout &lt;&lt; "main启动，threadid=" &lt;&lt; std::this_thread::get_id &lt;&lt; endl;</span><span class="token comment">//std::packaged_task&lt;int(int)&gt; mypt(mythread);//把mythread函数包装了起来,实现更多接口</span><span class="token comment">//std::thread t1(std::ref(mypt), 1);//1 是入口函数的参数</span><span class="token comment">//t1.join();</span><span class="token comment">//std::future&lt;int&gt; result = mypt.get_future();</span><span class="token comment">//cout &lt;&lt; result.get() &lt;&lt; endl;</span><span class="token comment">//写法2：</span>std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">mypt</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> mypar<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程开始执行啦，threadid为"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> mypar <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程执行结束啦，threadid为"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myTask<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>mypt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> myptr2<span class="token punctuation">;</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> myTask<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myptr2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//vector里面的第一个对象就复制到myptr2了</span>myTask<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//删除vector第一个元素，iter也没用了</span>std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>myptr2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1 是入口函数的参数</span>t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> myptr2<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="线程之间值的传递"><a href="#线程之间值的传递" class="headerlink" title="线程之间值的传递"></a>线程之间值的传递</h1><h2 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h2><p>promise的对象用于线程之间传递数值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span>std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">&amp;</span>tmp<span class="token punctuation">,</span><span class="token keyword">int</span> cal<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//</span>cal<span class="token operator">++</span><span class="token punctuation">;</span>cal <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> result <span class="token operator">=</span> cal<span class="token punctuation">;</span>tmp<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果保存到了tmp中</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">mythread2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">auto</span> result <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread2得到值"</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//std::promise的作用：线程之间值传递</span>std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> myprom<span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>myprom<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用myprom去获得得到的值。</span>t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> myprom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//fut即将得到myprom的值</span><span class="token comment">//auto result = fut.get();//get只能调用一次</span><span class="token comment">//cout &lt;&lt; "result=" &lt;&lt; result &lt;&lt; endl;</span>std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>mythread2<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>fut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h2><p>future的对象会在将来得到一个值。future的其他成员函数：枚举类型future_status，记录状态。</p><pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>future_status</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token keyword">int</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token keyword">int</span> mypra<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程开始执行啦，threadid为"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> mypra <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程执行结束啦，threadid为"</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//future的其他成员函数：枚举类型future_status</span><span class="token comment">//async是一个函数模板，启动一个异步任务：自动创建一个线程，并开始执行对应线程的入口函数</span>A a<span class="token punctuation">;</span><span class="token keyword">int</span> tmppra <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"main启动，threadid="</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span>get_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>mythread<span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> tmppra<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建了一个线程，入口函数为mythread（这个函数必须要返回一个值，不然后面有问题）。rusult还没这么快得到值，将来会拿到。先不管了，程序往下运行</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"continue……！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>future_status status <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">wait_for</span><span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//系统停在这里等待一秒钟.status保存result的状态：timeout，ready,deferred</span><span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//超时</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"超时了，线程还没有执行完！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//执行完了</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程执行完了！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status <span class="token operator">==</span> std<span class="token operator">::</span>future_status<span class="token operator">::</span>deferred<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果asnyc的第一个参数被设置为std::launch::deferred，本条件成立</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"线程延迟执行！"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i love china"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>future的对象get只能用一次，假如我多个线程想要获取某个结果，怎么办。这时shared_future就派上用场了。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span>std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tmp<span class="token punctuation">,</span> <span class="token keyword">int</span> cal<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread1开始执行，id："</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span>get_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cal <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds <span class="token function">dura</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>this_thread<span class="token operator">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>dura<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> result <span class="token operator">=</span> cal<span class="token punctuation">;</span>tmp<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//结果保存到了tmp中</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">mythread2</span><span class="token punctuation">(</span>std<span class="token operator">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread2开始执行，id："</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>this_thread<span class="token operator">::</span>get_id <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">auto</span> result <span class="token operator">=</span> tmp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"mythread2得到值"</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//future的其他成员函数：shared_future。get只能用一次，假如我多个线程想要获取某个结果，怎么办。</span>std<span class="token operator">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> myprom<span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">t1</span><span class="token punctuation">(</span>mythread<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>myprom<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">180</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//用myprom去获得得到的值。</span>t1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//std::future&lt;int&gt; fut = myprom.get_future();//fut即将得到myprom的值</span><span class="token comment">//auto result = fut.get();//future类型的对象的get（）只能调用一次!!!!!!!!!!!get()函数的设计，是一个移动语义。所以移动完，fut已经空了</span><span class="token comment">//cout &lt;&lt; "result=" &lt;&lt; result &lt;&lt; endl;</span><span class="token comment">//std::shared_future&lt;int&gt; fut_s(std::move(fut));//或者std::shared_future&lt;int&gt; fut_s(fut.share())</span>std<span class="token operator">::</span>shared_future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">fut_s</span><span class="token punctuation">(</span>myprom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">auto</span> tmpFut <span class="token operator">=</span> fut_s<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//此时的fut_s就是可以多次被调用get（）函数</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fut_s第一次get（），值为："</span> <span class="token operator">&lt;&lt;</span>tmpFut<span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">t2</span><span class="token punctuation">(</span>mythread2<span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">ref</span><span class="token punctuation">(</span>fut_s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"i love china"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="原子操作-atomic"><a href="#原子操作-atomic" class="headerlink" title="原子操作 atomic"></a>原子操作 atomic</h1><p>多个线程对一个变量进行读写操作，不加锁肯定会出现冲突错误。所以，引入原子操作：不会被打断的程序执行片段。就可以不用加锁了，但是只能针对一个变量的进行原子操作。<br>针对++，–，+=，&amp;=，等操作支持，a=a+1不支持。一般用于计数统计。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token operator">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> g_mycout <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//封装了一个类型为int的原子对象</span><span class="token comment">//std::mutex g_mutex;</span><span class="token keyword">void</span> <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//g_mutex.lock();</span>g_mycout<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">//此时它是原子操作，不会被打断了</span><span class="token comment">//g_mutex.unlock();</span><span class="token punctuation">}</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>std<span class="token operator">::</span>thread <span class="token function">mytobj1</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">mytobj2</span><span class="token punctuation">(</span>mythread<span class="token punctuation">)</span><span class="token punctuation">;</span>mytobj1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mytobj2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> g_mycout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"执行完毕"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="windows临界区以及特殊的互斥量mutex"><a href="#windows临界区以及特殊的互斥量mutex" class="headerlink" title="windows临界区以及特殊的互斥量mutex"></a>windows临界区以及特殊的互斥量mutex</h1><p>windows临界区，类似于c++11的mutes，相同的线程里面对于相同的临界区变量，可以允许多次加锁，但是也相应地调用一样多次的解锁，用类的构造函数和析构函数来实现临界区的自动进入和自动退出。<br>相类似的，递归的独占互斥量recursive_mutex。允许一个互斥量多次lock<br>带超时的互斥量timed_mutex和recursive_timed_mutex。超时了就不等了。接口：try_lock_for(时长)返回true就是获取了锁。try_lock_until(时间点)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">__WINDOWSJQ_</span></span><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__WINDOWSJQ_</span></span><span class="token function">InitializeCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// __WINDOWSJQ_</span></span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">inMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//线程1，插入命令到消息队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"插入命令："</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__WINDOWSJQ_</span></span><span class="token function">EnterCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">LeaveCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>std<span class="token operator">::</span><span class="token function">lock</span><span class="token punctuation">(</span>my_mutex1<span class="token punctuation">,</span> my_mutex2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//相当于每一个互斥量执行lock操作，</span>std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbgurad1</span><span class="token punctuation">(</span>my_mutex1<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//智能lock,构造时会自动执行lock函数。但是前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题</span>std<span class="token operator">::</span>lock_guard<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">sbgurad2</span><span class="token punctuation">(</span>my_mutex2<span class="token punctuation">,</span> std<span class="token operator">::</span>adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//智能lock,构造时会自动执行lock函数。但是前面已经执行了lock操作，需要添加std::adopt_lock参数来避免问题</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// __WINDOWSJQ_</span></span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">outMsgRecvQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//线程2，读取命令到消息队列</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__WINDOWSJQ_</span></span><span class="token function">EnterCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//消息不为空</span><span class="token keyword">int</span> command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理数据</span><span class="token function">LeaveCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//消息为空</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"读取命令，但是消息队列是空的"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token function">LeaveCriticalSection</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>my_winsec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span> <span class="token comment">// DEBUG</span></span>my_mutex1<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上锁</span>my_mutex2<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//上锁</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//消息不为空</span><span class="token keyword">int</span> command <span class="token operator">=</span> msgRecvQueue<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>msgRecvQueue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//处理数据</span>my_mutex1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>my_mutex2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//消息为空</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"读取命令，但是消息队列是空的"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>my_mutex1<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//因为有两个出口，所以每个出口都要写上unlock</span>my_mutex2<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span><span class="token operator">:</span>std<span class="token operator">::</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> msgRecvQueue<span class="token punctuation">;</span><span class="token comment">//玩家命令</span>std<span class="token operator">::</span>mutex my_mutex1<span class="token punctuation">;</span><span class="token comment">//创建一个互斥量</span>std<span class="token operator">::</span>mutex my_mutex2<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">__WINDOWSJQ_</span></span>CRITICAL_SECTION my_winsec<span class="token punctuation">;</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// 临界区__WINDOWSJQ_</span></span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>A myobj<span class="token punctuation">;</span>std<span class="token operator">::</span>thread <span class="token function">mythread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>outMsgRecvQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myobj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二个参数是引用，这样才能保证操作的是同一个对象</span>std<span class="token operator">::</span>thread <span class="token function">mythread2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>A<span class="token operator">::</span>inMsgRecvQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>myobj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//第二个参数是引用，这样才能保证操作的是同一个对象</span>mythread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mythread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h1><p>原子操作：读load（），写store（）<br>线程池：把一堆线程放到一起，统一管理，循环利用，用完放回去。场景假设：服务器为客户端提供服务，来一个客户端，服务器就为它创建一个新的线程。但是如果客户端特别多……创建线程很有可能创建失败了，后面就崩溃了。实现方法：程序启动时，一次性建好一定数量的线程<br>线程数量极限：2000个<br>数量建议：使用接口有指定数量，就严格按照数量来</p>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++,IT,Skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Let&#39;s Learn Docker Now</title>
      <link href="2021/02/12/let-s-learn-docker-now/"/>
      <url>2021/02/12/let-s-learn-docker-now/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h1><p><a href="https://imgchr.com/i/yrVlD0"><img src="https://s3.ax1x.com/2021/02/12/yrVlD0.png" alt="Docker组件关系图"></a><br><strong>镜像image</strong>：镜像就好比是一个模板，通过镜像run，创建容器服务，镜像可以创建多个容器<br><strong>容器container</strong>：利用容器独立运行一个或一组应用。启动、停止、删除。可以把容器理解为一个简单的Linux系统<br><strong>仓库repository</strong>：存放镜像的地方</p><h1 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h1><h2 id="查看系统环境"><a href="#查看系统环境" class="headerlink" title="查看系统环境"></a>查看系统环境</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看系统内核</span><span class="token function">uname</span> -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#查看系统版本</span><span class="token function">cat</span> /etc/os-release<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#卸载旧版本的docker</span><span class="token function">sudo</span> yum remove docker <span class="token punctuation">\</span>                   docker-client <span class="token punctuation">\</span>                   docker-client-latest <span class="token punctuation">\</span>                   docker-common <span class="token punctuation">\</span>                   docker-latest <span class="token punctuation">\</span>                   docker-latest-logrotate <span class="token punctuation">\</span>                   docker-logrotate <span class="token punctuation">\</span>                   docker-engine<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#安装必要环境</span><span class="token function">sudo</span> yum <span class="token function">install</span> -y yum-utils<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#设置镜像仓库 </span><span class="token function">sudo</span> yum-config-manager <span class="token punctuation">\</span>      --add-repo <span class="token punctuation">\</span><span class="token comment">#这个是国外的，有点慢</span>https://download.docker.com/linux/centos/docker-ce.repo yum-config-manager <span class="token punctuation">\</span>--add-repo <span class="token punctuation">\</span>http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#更新yum索引 </span>yum makecache fast<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#安装docker</span><span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#启动docker </span><span class="token function">sudo</span> systemctl start docker   <span class="token comment">#测试是否安装成功   </span>docker version   <span class="token comment">#测试hello world   </span>docker run hello-world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看到如下画面，说明Docker安装成功<br><a href="https://imgchr.com/i/yrVJ5F"><img src="https://s3.ax1x.com/2021/02/12/yrVJ5F.png" alt="启动Docker运行结果"></a></p><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><p>登录阿里云，找到容器镜像服务，镜像加速器，里面有详细方法，粘贴提供的命令到服务器即可。<br><a href="https://imgchr.com/i/ys2NdJ"><img src="https://s3.ax1x.com/2021/02/14/ys2NdJ.png" alt="阿里云镜像加速网页操作.png"></a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> -p /etc/docker<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'{  "registry-mirrors": ["https://ch6b7wpt.mirror.aliyuncs.com"]}EOF</span><span class="token function">sudo</span> systemctl daemon-reload<span class="token function">sudo</span> systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Docker原理"><a href="#Docker原理" class="headerlink" title="Docker原理"></a>Docker原理</h1><h2 id="Docker运行过程"><a href="#Docker运行过程" class="headerlink" title="Docker运行过程"></a>Docker运行过程</h2><p><a href="https://imgchr.com/i/ys4xqf"><img src="https://s3.ax1x.com/2021/02/14/ys4xqf.jpg" alt="Docker运行流程.jpg"></a></p><h2 id="Docker组件原理"><a href="#Docker组件原理" class="headerlink" title="Docker组件原理"></a>Docker组件原理</h2><p>Docker是一个client-server结构的系统，Docker的守护进程运行在主机上，通过websocket从客户端进行访问。<br>Docker-server接收Docker-client的指令<br><a href="https://imgchr.com/i/ys55Ss"><img src="https://s3.ax1x.com/2021/02/14/ys55Ss.jpg" alt="Docker组件关系原理.jpg"></a></p><h2 id="为什么Docker比VM快"><a href="#为什么Docker比VM快" class="headerlink" title="为什么Docker比VM快"></a>为什么Docker比VM快</h2><p>1、Docker有比虚拟机更少的抽象层<br>2、Docker使用的是宿主机的内核，虚拟机需要的Guest OS。新建容器的时候，Docker不需要重新加载一个操作系统<br><a href="https://imgchr.com/i/yyX0oR"><img src="https://s3.ax1x.com/2021/02/15/yyX0oR.jpg" alt="虚拟机与Docker内核架构对比图.jpg"></a></p><h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker version  <span class="token comment">#显示docker的版本信息</span>docker info<span class="token comment">#显示docker的系统信息，包括镜像、容器的数量</span>docker xx命令 --help<span class="token comment">#显示docker命令的帮助</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/y4SAI0"><img src="https://s3.ax1x.com/2021/02/19/y4SAI0.png" alt="可查看的命令的网址"></a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="获取所有镜像"><a href="#获取所有镜像" class="headerlink" title="获取所有镜像"></a>获取所有镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker images REPOSITORY    TAG       IMAGE ID       CREATED         SIZEhello-world   latest    bf756fb1ae65   <span class="token number">13</span> months ago   <span class="token number">13</span>.3kB<span class="token comment">#REPOSITORY镜像的仓库原</span><span class="token comment">#TAG 镜像的标签</span><span class="token comment">#IMAGE ID 镜像的ID号</span><span class="token comment">#CREATED 镜像的创建时间</span><span class="token comment">#SIZE镜像的大小</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker search mysql -f<span class="token operator">=</span>STARS<span class="token operator">=</span><span class="token number">3000</span>NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATEDmysql     MySQL is a widely used, open-source relation…   <span class="token number">10520</span>     <span class="token punctuation">[</span>OK<span class="token punctuation">]</span>       mariadb   MariaDB is a community-developed fork of MyS…   <span class="token number">3928</span>      <span class="token punctuation">[</span>OK<span class="token punctuation">]</span><span class="token comment">#-f 筛选命令，例子是筛选stars大于三千的镜像</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull mysqlUsing default tag: latest  <span class="token comment">#命令如果不写tag，默认下载latest版本</span>latest: Pulling from library/mysql45b42c59be33: Pull complete <span class="token comment">#分层下载，这是docker image的核心，联合文件系统</span>b4f790bd91da: Pull complete 325ae51788e9: Pull complete adcb9439d751: Pull complete 174c7fe16c78: Pull complete 698058ef136c: Pull complete 4690143a669e: Pull complete f7599a246fd6: Pull complete 35a55bf0c196: Pull complete 790ac54f4c47: Pull complete 18602acc97e1: Pull complete 365caa3500d0: Pull complete Digest: sha256:b1cc887ed32cc6c2f217b12703bd05f503f2037892c8bb226047fe5dff85a109  <span class="token comment">#签名</span>Status: Downloaded newer image <span class="token keyword">for</span> mysql:latestdocker.io/library/mysql:latest <span class="token comment">#真实地址</span><span class="token comment">#所以docker pull mysql 等价于 docker pull docker.io/library/mysql:latest</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull mysql:5.7  <span class="token comment">#添加了标签</span><span class="token number">5.7</span>: Pulling from library/mysql45b42c59be33: Already exists <span class="token comment">#这就是联合文件系统的妙处，有很多文件其实已经存在的，不需要再下载了，只需要下载差异的部分，大大减少了存储的消耗</span>b4f790bd91da: Already exists 325ae51788e9: Already exists adcb9439d751: Already exists 174c7fe16c78: Already exists 698058ef136c: Already exists 4690143a669e: Already exists 66676c1ab9b3: Pull complete 25ebf78a38b6: Extracting <span class="token punctuation">[</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">&gt;</span>                          <span class="token punctuation">]</span>  <span class="token number">52</span>.92MB/108.4MB349a839d5e27: Download complete 40b03e3e5980: Download complete <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># docker rmi -f 镜像id 镜像id2 ……</span>docker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images -aq<span class="token variable">)</span></span>  <span class="token comment">#删除当前所有镜像，$()以参数传入，里面的内容是查出来的所有镜像的id</span>Untagged: mysql:5.7Untagged: mysql@sha256:853105ad984a9fe87dd109be6756e1fbdba8b003b303d88ac0dda6b455f36556Deleted: sha256:5f47254ca5817f99cdd387ce7345d43e770e0682a4c81b62776f3347551b1d85Deleted: sha256:63f5d2725ff0ecffe0a7345e749d39b269a8cef04984661f0f4e752869b9fbb1Deleted: sha256:acbe85abff4e7bbdd75a1f56ee9a095a72fcba4c226d0194d46b9a8471b1fe18Deleted: sha256:b851a484b18c5d3d25497260c111631ae3adf924eb10baa533b2a5b03b339d1aDeleted: sha256:b5133b076285236e7fd98c42c1f18f57e2b4ed98daaed7b0afb3b98b804d6f25Untagged: mysql:latestUntagged: mysql@sha256:b1cc887ed32cc6c2f217b12703bd05f503f2037892c8bb226047fe5dff85a109Deleted: sha256:2933adc350f3b62c05a66f700fba68ef93997d67263121250ec7848c50dcf3f5Deleted: sha256:78b6531a3acdad2154a839ac1ec9ae2677632cc834bd996e75317f6e35717834Deleted: sha256:f0c1c423000a6848e30ae3249c25b16f678167e56b4bb3013445b2ad1d179e8c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># docker run [可选参数] image</span><span class="token comment"># 参数说明</span>--name<span class="token operator">=</span><span class="token string">"name1"</span>  容器启动后的名字，用于区分-d 后台运行，类似 <span class="token function">nohup</span>-it 使用交互方式运行，进入容器查看容器-p <span class="token number">8080</span>:8080 指定容器端口。ip:主机端口:容器端口<span class="token punctuation">(</span>常用<span class="token punctuation">)</span>-P 随机指定端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/yhzvPf"><img src="https://s3.ax1x.com/2021/02/19/yhzvPf.png" alt="进入容器"></a></p><h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker <span class="token function">ps</span> <span class="token comment">#正在运行的容器</span>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMESdocker <span class="token function">ps</span> -a <span class="token comment">#查看曾经运行的所有容器</span>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES8fc216825a94   centos    <span class="token string">"/bin/bash"</span>   <span class="token number">5</span> minutes ago   Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">2</span> minutes ago             flamboyant_ptolemy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/yhzOat"><img src="https://s3.ax1x.com/2021/02/19/yhzOat.png" alt="查看正在运行的容器"></a></p><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ctrl+p+q <span class="token punctuation">(</span>退出但是不停止<span class="token punctuation">)</span>或者 <span class="token builtin class-name">exit</span> <span class="token punctuation">(</span>退出并停止<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/yhzI2D"><img src="https://s3.ax1x.com/2021/02/19/yhzI2D.png" alt="退出容器操作"></a></p><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker <span class="token function">rm</span> 容器id <span class="token comment">#没法删除正在运行的容器</span>docker <span class="token function">rm</span> -f 容器id$ docker <span class="token function">ps</span> -a -q <span class="token operator">|</span> <span class="token function">xargs</span> docker <span class="token function">rm</span> -f <span class="token comment">#删除所有容器的骚操作</span>715959ece1f08fc216825a94<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="启动和停止容器"><a href="#启动和停止容器" class="headerlink" title="启动和停止容器"></a>启动和停止容器</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker start 容器id <span class="token comment">#启动容器。对比run，run是有创建的过程，start是已经存在的容器s</span>docker restart 容器iddocker stop  容器id<span class="token comment">#停止容器</span>docker <span class="token function">kill</span> 容器id <span class="token comment">#强制停止容器，当stop不好使的时候</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>问题<br><a href="https://imgchr.com/i/yhzYuj"><img src="https://s3.ax1x.com/2021/02/19/yhzYuj.png" alt="容器退出的问题"></a><br>我在使用docker后台启动的时候，发现他并没有在运行，自己退出了。<br>原因：<br>这是因为docker在启动后，需要有前台服务，当发现自己没有提供服务，就自杀了。<strong>发现自己没用，就自杀了</strong></p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker logs -f -t --tail 日志的条数 容器id<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="查看容器中的进程信息"><a href="#查看容器中的进程信息" class="headerlink" title="查看容器中的进程信息"></a>查看容器中的进程信息</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker <span class="token function">top</span> 90ac614554b0  <span class="token comment"># docker top 容器id</span>PID                 <span class="token environment constant">USER</span>                TIME                COMMAND<span class="token number">609</span>                 root                <span class="token number">0</span>:00                /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="查看容器的元数据"><a href="#查看容器的元数据" class="headerlink" title="查看容器的元数据"></a>查看容器的元数据</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#docker inspect 容器id</span>docker inspect 90ac614554b0<span class="token punctuation">[</span>    <span class="token punctuation">{</span>        <span class="token string">"Id"</span><span class="token builtin class-name">:</span> <span class="token string">"90ac614554b07430e0d3923e7b8c9ed4c054cda9f3d97b02fea1d946bbe70a73"</span>,        <span class="token string">"Created"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-02-19T13:35:31.361495346Z"</span>,        <span class="token string">"Path"</span><span class="token builtin class-name">:</span> <span class="token string">"/bin/bash"</span>,        <span class="token string">"Args"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,        <span class="token string">"State"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>            <span class="token string">"Status"</span><span class="token builtin class-name">:</span> <span class="token string">"running"</span>,            <span class="token string">"Running"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"Paused"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"Restarting"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"OOMKilled"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"Dead"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"Pid"</span><span class="token builtin class-name">:</span> <span class="token number">609</span>,            <span class="token string">"ExitCode"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"Error"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"StartedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-02-19T13:53:56.943744407Z"</span>,            <span class="token string">"FinishedAt"</span><span class="token builtin class-name">:</span> <span class="token string">"2021-02-19T13:36:20.041390055Z"</span>        <span class="token punctuation">}</span>,        <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"sha256:300e315adb2f96afe5f0b2780b87f28ae95231fe3bdd1e16b9ba606307728f55"</span>,        <span class="token string">"ResolvConfPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/90ac614554b07430e0d3923e7b8c9ed4c054cda9f3d97b02fea1d946bbe70a73/resolv.conf"</span>,        <span class="token string">"HostnamePath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/90ac614554b07430e0d3923e7b8c9ed4c054cda9f3d97b02fea1d946bbe70a73/hostname"</span>,        <span class="token string">"HostsPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/90ac614554b07430e0d3923e7b8c9ed4c054cda9f3d97b02fea1d946bbe70a73/hosts"</span>,        <span class="token string">"LogPath"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/containers/90ac614554b07430e0d3923e7b8c9ed4c054cda9f3d97b02fea1d946bbe70a73/90ac614554b07430e0d3923e7b8c9ed4c054cda9f3d97b02fea1d946bbe70a73-json.log"</span>,        <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"/cent1"</span>,        <span class="token string">"RestartCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,        <span class="token string">"Driver"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>,        <span class="token string">"Platform"</span><span class="token builtin class-name">:</span> <span class="token string">"linux"</span>,        <span class="token string">"MountLabel"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"ProcessLabel"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,        <span class="token string">"AppArmorProfile"</span><span class="token builtin class-name">:</span> <span class="token string">"docker-default"</span>,        <span class="token string">"ExecIDs"</span><span class="token builtin class-name">:</span> null,        <span class="token string">"HostConfig"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>            <span class="token string">"Binds"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"ContainerIDFile"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"LogConfig"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>                <span class="token string">"Type"</span><span class="token builtin class-name">:</span> <span class="token string">"json-file"</span>,                <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>            <span class="token punctuation">}</span>,            <span class="token string">"NetworkMode"</span><span class="token builtin class-name">:</span> <span class="token string">"default"</span>,            <span class="token string">"PortBindings"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,            <span class="token string">"RestartPolicy"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>                <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"no"</span>,                <span class="token string">"MaximumRetryCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>            <span class="token punctuation">}</span>,            <span class="token string">"AutoRemove"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"VolumeDriver"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"VolumesFrom"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CapAdd"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CapDrop"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CgroupnsMode"</span><span class="token builtin class-name">:</span> <span class="token string">"host"</span>,            <span class="token string">"Dns"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"DnsOptions"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"DnsSearch"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"ExtraHosts"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"GroupAdd"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"IpcMode"</span><span class="token builtin class-name">:</span> <span class="token string">"private"</span>,            <span class="token string">"Cgroup"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Links"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"OomScoreAdj"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"PidMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Privileged"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"PublishAllPorts"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"ReadonlyRootfs"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"SecurityOpt"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"UTSMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"UsernsMode"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"ShmSize"</span><span class="token builtin class-name">:</span> <span class="token number">67108864</span>,            <span class="token string">"Runtime"</span><span class="token builtin class-name">:</span> <span class="token string">"runc"</span>,            <span class="token string">"ConsoleSize"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token number">0</span>,                <span class="token number">0</span>            <span class="token punctuation">]</span>,            <span class="token string">"Isolation"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"CpuShares"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"Memory"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"NanoCpus"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CgroupParent"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"BlkioWeight"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"BlkioWeightDevice"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"BlkioDeviceReadBps"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"BlkioDeviceWriteBps"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"BlkioDeviceReadIOps"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"BlkioDeviceWriteIOps"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CpuPeriod"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpuQuota"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpuRealtimePeriod"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpuRealtimeRuntime"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpusetCpus"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"CpusetMems"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Devices"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,            <span class="token string">"DeviceCgroupRules"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"DeviceRequests"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"KernelMemory"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"KernelMemoryTCP"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"MemoryReservation"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"MemorySwap"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"MemorySwappiness"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"OomKillDisable"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"PidsLimit"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"Ulimits"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"CpuCount"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"CpuPercent"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"IOMaximumIOps"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"IOMaximumBandwidth"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"MaskedPaths"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"/proc/asound"</span>,                <span class="token string">"/proc/acpi"</span>,                <span class="token string">"/proc/kcore"</span>,                <span class="token string">"/proc/keys"</span>,                <span class="token string">"/proc/latency_stats"</span>,                <span class="token string">"/proc/timer_list"</span>,                <span class="token string">"/proc/timer_stats"</span>,                <span class="token string">"/proc/sched_debug"</span>,                <span class="token string">"/proc/scsi"</span>,                <span class="token string">"/sys/firmware"</span>            <span class="token punctuation">]</span>,            <span class="token string">"ReadonlyPaths"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"/proc/bus"</span>,                <span class="token string">"/proc/fs"</span>,                <span class="token string">"/proc/irq"</span>,                <span class="token string">"/proc/sys"</span>,                <span class="token string">"/proc/sysrq-trigger"</span>            <span class="token punctuation">]</span>        <span class="token punctuation">}</span>,        <span class="token string">"GraphDriver"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>            <span class="token string">"Data"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>                <span class="token string">"LowerDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/8a551c6f7e886c75e9c5a3288984499bfcfebc85e085f725af26d6b373dddd13-init/diff:/var/lib/docker/overlay2/c904e1053a91f9ae4c15a5bb099fcbd3d3d35710e7a2fff9359d3b3f9d3d3ca8/diff"</span>,                <span class="token string">"MergedDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/8a551c6f7e886c75e9c5a3288984499bfcfebc85e085f725af26d6b373dddd13/merged"</span>,                <span class="token string">"UpperDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/8a551c6f7e886c75e9c5a3288984499bfcfebc85e085f725af26d6b373dddd13/diff"</span>,                <span class="token string">"WorkDir"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/lib/docker/overlay2/8a551c6f7e886c75e9c5a3288984499bfcfebc85e085f725af26d6b373dddd13/work"</span>            <span class="token punctuation">}</span>,            <span class="token string">"Name"</span><span class="token builtin class-name">:</span> <span class="token string">"overlay2"</span>        <span class="token punctuation">}</span>,        <span class="token string">"Mounts"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>,        <span class="token string">"Config"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>            <span class="token string">"Hostname"</span><span class="token builtin class-name">:</span> <span class="token string">"90ac614554b0"</span>,            <span class="token string">"Domainname"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"User"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"AttachStdin"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"AttachStdout"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"AttachStderr"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"Tty"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"OpenStdin"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"StdinOnce"</span><span class="token builtin class-name">:</span> true,            <span class="token string">"Env"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>            <span class="token punctuation">]</span>,            <span class="token string">"Cmd"</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span>                <span class="token string">"/bin/bash"</span>            <span class="token punctuation">]</span>,            <span class="token string">"Image"</span><span class="token builtin class-name">:</span> <span class="token string">"centos"</span>,            <span class="token string">"Volumes"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"WorkingDir"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"Entrypoint"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"OnBuild"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"Labels"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>                <span class="token string">"org.label-schema.build-date"</span><span class="token builtin class-name">:</span> <span class="token string">"20201204"</span>,                <span class="token string">"org.label-schema.license"</span><span class="token builtin class-name">:</span> <span class="token string">"GPLv2"</span>,                <span class="token string">"org.label-schema.name"</span><span class="token builtin class-name">:</span> <span class="token string">"CentOS Base Image"</span>,                <span class="token string">"org.label-schema.schema-version"</span><span class="token builtin class-name">:</span> <span class="token string">"1.0"</span>,                <span class="token string">"org.label-schema.vendor"</span><span class="token builtin class-name">:</span> <span class="token string">"CentOS"</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>,        <span class="token string">"NetworkSettings"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>            <span class="token string">"Bridge"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"SandboxID"</span><span class="token builtin class-name">:</span> <span class="token string">"9db19da479143dc143bf9b0e1994a975045097c0a4b1ecdc397c91c7cc7a7989"</span>,            <span class="token string">"HairpinMode"</span><span class="token builtin class-name">:</span> false,            <span class="token string">"LinkLocalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"LinkLocalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"Ports"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,            <span class="token string">"SandboxKey"</span><span class="token builtin class-name">:</span> <span class="token string">"/var/run/docker/netns/9db19da47914"</span>,            <span class="token string">"SecondaryIPAddresses"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"SecondaryIPv6Addresses"</span><span class="token builtin class-name">:</span> null,            <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"98f554541cac644ee92e8ae0dea5afe2259830091429390ca98274ca4fd1611f"</span>,            <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>,            <span class="token string">"GlobalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"GlobalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,            <span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.2"</span>,            <span class="token string">"IPPrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,            <span class="token string">"IPv6Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,            <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:02"</span>,            <span class="token string">"Networks"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>                <span class="token string">"bridge"</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>                    <span class="token string">"IPAMConfig"</span><span class="token builtin class-name">:</span> null,                    <span class="token string">"Links"</span><span class="token builtin class-name">:</span> null,                    <span class="token string">"Aliases"</span><span class="token builtin class-name">:</span> null,                    <span class="token string">"NetworkID"</span><span class="token builtin class-name">:</span> <span class="token string">"6739e53bf1aa2d293dfe961a3fd5b0042e04ea6f5d0650a1efd2219e2fc74060"</span>,                    <span class="token string">"EndpointID"</span><span class="token builtin class-name">:</span> <span class="token string">"98f554541cac644ee92e8ae0dea5afe2259830091429390ca98274ca4fd1611f"</span>,                    <span class="token string">"Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.1"</span>,                    <span class="token string">"IPAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"172.17.0.2"</span>,                    <span class="token string">"IPPrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">16</span>,                    <span class="token string">"IPv6Gateway"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,                    <span class="token string">"GlobalIPv6Address"</span><span class="token builtin class-name">:</span> <span class="token string">""</span>,                    <span class="token string">"GlobalIPv6PrefixLen"</span><span class="token builtin class-name">:</span> <span class="token number">0</span>,                    <span class="token string">"MacAddress"</span><span class="token builtin class-name">:</span> <span class="token string">"02:42:ac:11:00:02"</span>,                    <span class="token string">"DriverOpts"</span><span class="token builtin class-name">:</span> null                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#docker exec -it 容器id bashshell</span>docker <span class="token builtin class-name">exec</span> -it 90ac614554b0 /bin/bash<span class="token punctuation">[</span>root@90ac614554b0 /<span class="token punctuation">]</span><span class="token comment"># ls</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="token punctuation">[</span>root@90ac614554b0 /<span class="token punctuation">]</span><span class="token comment"># ps </span>  PID TTY          TIME CMD   <span class="token number">24</span> pts/1    00:00:00 <span class="token function">bash</span>   <span class="token number">40</span> pts/1    00:00:00 <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#docker attach 容器id</span>docker attach 90ac614554b0<span class="token punctuation">[</span>root@90ac614554b0 /<span class="token punctuation">]</span><span class="token comment"># </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>二者的区别</strong><br>docker exec 是以<strong>新的终端</strong>形式进入容器<br>docker attach 是直接进入<strong>正在运行的终端</strong></p><h3 id="从容器中拷贝文件出来"><a href="#从容器中拷贝文件出来" class="headerlink" title="从容器中拷贝文件出来"></a>从容器中拷贝文件出来</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># docker cp 容器id:路径 本地路径</span><span class="token punctuation">[</span>node1<span class="token punctuation">]</span> <span class="token punctuation">(</span>local<span class="token punctuation">)</span> root@192.168.0.8 /$ docker attach 90ac614554b0<span class="token punctuation">[</span>root@90ac614554b0 /<span class="token punctuation">]</span><span class="token comment"># ls</span>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<span class="token punctuation">[</span>root@90ac614554b0 /<span class="token punctuation">]</span><span class="token comment"># cd home/   </span><span class="token punctuation">[</span>root@90ac614554b0 home<span class="token punctuation">]</span><span class="token comment"># ls</span><span class="token punctuation">[</span>root@90ac614554b0 home<span class="token punctuation">]</span><span class="token comment"># touch hello.java</span><span class="token punctuation">[</span>root@90ac614554b0 home<span class="token punctuation">]</span><span class="token comment"># ls</span>hello.java<span class="token punctuation">[</span>root@90ac614554b0 home<span class="token punctuation">]</span><span class="token comment"># exit</span><span class="token builtin class-name">exit</span><span class="token punctuation">[</span>node1<span class="token punctuation">]</span> <span class="token punctuation">(</span>local<span class="token punctuation">)</span> root@192.168.0.8 /$ docker <span class="token function">ps</span>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<span class="token punctuation">[</span>node1<span class="token punctuation">]</span> <span class="token punctuation">(</span>local<span class="token punctuation">)</span> root@192.168.0.8 /$ docker <span class="token function">ps</span> -aCONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                      PORTS     NAMES90ac614554b0   centos    <span class="token string">"/bin/bash"</span>   <span class="token number">44</span> minutes ago   Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">51</span> seconds ago             cent154158da32d31   centos    <span class="token string">"/bin/bash"</span>   <span class="token number">46</span> minutes ago   Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">46</span> minutes ago             confident_mahaviraf34bfb7115ce   centos    <span class="token string">"/bin/bash"</span>   <span class="token number">47</span> minutes ago   Exited <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">47</span> minutes ago             hopeful_burnell<span class="token punctuation">[</span>node1<span class="token punctuation">]</span> <span class="token punctuation">(</span>local<span class="token punctuation">)</span> root@192.168.0.8 /$ docker <span class="token function">cp</span> 90ac614554b0:/home/hello.java /<span class="token punctuation">[</span>node1<span class="token punctuation">]</span> <span class="token punctuation">(</span>local<span class="token punctuation">)</span> root@192.168.0.8 /$ <span class="token function">ls</span>bin         dev         etc         home        media       opt         root        sbin        sys         usrcerts       docker.log  hello.java  lib         mnt         proc        run         srv         tmp         var<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><p><a href="https://imgchr.com/i/yhzi4K"><img src="https://s3.ax1x.com/2021/02/19/yhzi4K.png" alt="docker命令图示"></a></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Usage:  docker <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> COMMANDA self-sufficient runtime <span class="token keyword">for</span> containersOptions:      --config string      Location of client config files <span class="token punctuation">(</span>default <span class="token string">"/root/.docker"</span><span class="token punctuation">)</span>  -c, --context string     Name of the context to use to connect to the daemon <span class="token punctuation">(</span>overrides DOCKER_HOST <span class="token function">env</span> var and default                           context <span class="token builtin class-name">set</span> with <span class="token string">"docker context use"</span><span class="token punctuation">)</span>  -D, --debug              Enable debug mode  -H, --host list          Daemon socket<span class="token punctuation">(</span>s<span class="token punctuation">)</span> to connect to  -l, --log-level string   Set the logging level <span class="token punctuation">(</span><span class="token string">"debug"</span><span class="token operator">|</span><span class="token string">"info"</span><span class="token operator">|</span><span class="token string">"warn"</span><span class="token operator">|</span><span class="token string">"error"</span><span class="token operator">|</span><span class="token string">"fatal"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>default <span class="token string">"info"</span><span class="token punctuation">)</span>      --tls                Use TLS<span class="token punctuation">;</span> implied by --tlsverify      --tlscacert string   Trust certs signed only by this CA <span class="token punctuation">(</span>default <span class="token string">"/root/.docker/ca.pem"</span><span class="token punctuation">)</span>      --tlscert string     Path to TLS certificate <span class="token function">file</span> <span class="token punctuation">(</span>default <span class="token string">"/root/.docker/cert.pem"</span><span class="token punctuation">)</span>      --tlskey string      Path to TLS key <span class="token function">file</span> <span class="token punctuation">(</span>default <span class="token string">"/root/.docker/key.pem"</span><span class="token punctuation">)</span>      --tlsverify          Use TLS and verify the remote  -v, --version            Print version information and quitManagement Commands:  app*        Docker App <span class="token punctuation">(</span>Docker Inc., v0.9.1-beta3<span class="token punctuation">)</span>  builder     Manage builds  checkpoint  Manage checkpoints  config      Manage Docker configs  container   Manage containers  context     Manage contexts  image       Manage images  manifest    Manage Docker image manifests and manifest lists  network     Manage networks  node        Manage Swarm nodes  plugin      Manage plugins  secret      Manage Docker secrets  <span class="token function">service</span>     Manage services  stack       Manage Docker stacks  swarm       Manage Swarm  system      Manage Docker  trust       Manage trust on Docker images  volume      Manage volumesCommands:  attach      Attach <span class="token builtin class-name">local</span> standard input, output, and error streams to a running container  build       Build an image from a Dockerfile  commit      Create a new image from a container<span class="token string">'s changes  cp          Copy files/folders between a container and the local filesystem  create      Create a new container  diff        Inspect changes to files or directories on a container'</span>s filesystem  events      Get real <span class="token function">time</span> events from the server  <span class="token builtin class-name">exec</span>        Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a running container  <span class="token builtin class-name">export</span>      Export a container's filesystem as a <span class="token function">tar</span> archive  <span class="token function">history</span>     Show the <span class="token function">history</span> of an image  images      List images  <span class="token function">import</span>      Import the contents from a tarball to create a filesystem image  info        Display system-wide information  inspect     Return low-level information on Docker objects  <span class="token function">kill</span>        Kill one or <span class="token function">more</span> running containers  load        Load an image from a <span class="token function">tar</span> archive or STDIN  login       Log <span class="token keyword">in</span> to a Docker registry  <span class="token builtin class-name">logout</span>      Log out from a Docker registry  logs        Fetch the logs of a container  pause       Pause all processes within one or <span class="token function">more</span> containers  port        List port mappings or a specific mapping <span class="token keyword">for</span> the container  <span class="token function">ps</span>          List containers  pull        Pull an image or a repository from a registry  push        Push an image or a repository to a registry  <span class="token function">rename</span>      Rename a container  restart     Restart one or <span class="token function">more</span> containers  <span class="token function">rm</span>          Remove one or <span class="token function">more</span> containers  rmi         Remove one or <span class="token function">more</span> images  run         Run a <span class="token builtin class-name">command</span> <span class="token keyword">in</span> a new container  save        Save one or <span class="token function">more</span> images to a <span class="token function">tar</span> archive <span class="token punctuation">(</span>streamed to STDOUT by default<span class="token punctuation">)</span>  search      Search the Docker Hub <span class="token keyword">for</span> images  start       Start one or <span class="token function">more</span> stopped containers  stats       Display a live stream of container<span class="token punctuation">(</span>s<span class="token punctuation">)</span> resource usage statistics  stop        Stop one or <span class="token function">more</span> running containers  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE  <span class="token function">top</span>         Display the running processes of a container  unpause     Unpause all processes within one or <span class="token function">more</span> containers  update      Update configuration of one or <span class="token function">more</span> containers  version     Show the Docker version information  <span class="token function">wait</span>        Block <span class="token keyword">until</span> one or <span class="token function">more</span> containers stop, <span class="token keyword">then</span> print their <span class="token builtin class-name">exit</span> codes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Skills </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker,IT,Skills </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>First Blog</title>
      <link href="2021/02/12/first-blog/"/>
      <url>2021/02/12/first-blog/</url>
      
        <content type="html"><![CDATA[<h1 id="Welcoming-speech"><a href="#Welcoming-speech" class="headerlink" title="Welcoming speech"></a>Welcoming speech</h1><p>Hi everyone：<br>Welcome to <strong>Kuan</strong>‘s blog. Today is February 12, 2021, <strong>the birtyday of my blog website</strong>.<br>I’ll update <strong>my article here</strong> occasionally from today. Please <strong>give me more advice</strong>.<br>Thanks.</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Commemoration </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
